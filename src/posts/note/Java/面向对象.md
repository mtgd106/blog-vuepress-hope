---
title: 面向对象
author: 
  name: 北斗星司
category: 
  - 基础知识
tag: 
  - 语法
date: 2023-7-12 15:08:32
icon: file
---

<!-- permalink: /    -->





## 修饰符

### 访问修饰符

|  修饰符   |                         类的使用范围                         |
| :-------: | :----------------------------------------------------------: |
|  private  |                       只能在本类中调用                       |
|  default  |                 只要是在同一个包中就可以调用                 |
| protected | 在同一个包中的类可以调用；在其他包中，如果是其子类，也可以调用 |
|  public   |                      任何地方都可以调用                      |

 **注意：**

1. 对外部class的权限修饰只能用public或default

2. public类可以在任意地方被访问，default类只能被同一个包内部的类访问  

### 非访问修饰符

1. static

   修饰变量-----静态变量

   &ensp;&ensp;static用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量都只有一份拷贝。

   &ensp;&ensp;**静态变量也被称为类变量；局部变量不能被声明为static变量**

   &ensp;&ensp;类变量可以通过类名访问，也可以通过对象名访问。

   修饰方法-----静态方法

&ensp;&ensp;&ensp;&ensp;static用来声明独立于对象的静态方法，静态方法可以通过类名访问，也可以通过对象名访问。

&ensp;&ensp;&ensp;&ensp;**静态方法不能使用类的非静态变量**，静态方法从参数列表获得数据

2. finial

&ensp;&ensp;用来修饰类、方法和变量

&ensp;&ensp;final 修饰的类不能够被继承

&ensp;&ensp;final修饰的方法可以被子类继承，但不能被子类重写

&ensp;&ensp;final修饰的变量为常量，不可修改; **被final修饰的实例变量必须显式指定初始值**

3. abstract 

   修饰类-----抽象类

   &ensp;&ensp;抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充

   &ensp;&ensp;如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误

   &ensp;&ensp;**抽象类可以包含抽象方法和非抽象方法。抽象类也可以不包含抽象方法。**

   修饰方法----抽象方法

   &ensp;&ensp;抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。

   &ensp;&ensp;**抽象方法不能被声明为 final 和 static。**

   &ensp;&ensp;任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。



## 成员变量和局部变量

### 成员变量(属性)

1. 实例变量

   声明在一个类中，但在方法和语句块之外，不以static修饰

   当一个对象被实例化之后，每个实例变量的值就随之确定

   **访问修饰符可以用于修饰实例变量**

2. 类变量(静态变量)

   声明在一个类中，但在方法和语句块之外，以static修饰

   无论一个类创建了多少个对象，**类只拥有类变量的一份拷贝**

   静态变量存储在静态储存区，初始化后不可改变;在第一次被访问时创建，在程序结束时销毁

### 局部变量

声明在方法或语句块中

**访问修饰符不能用于修饰局部变量** 

|      区别      |                  成员变量                  |                   局部变量                   |
| :------------: | :----------------------------------------: | :------------------------------------------: |
|  类中位置不同  |                 类中方法外                 |             方法内或者方法声明上             |
| 内存中位置不同 |                   堆内存                   |                    栈内存                    |
|  生命周期不同  | 随着对象的创建而存在，随着对象的消失而消失 |  随着方法的调用而存在，随着方法的结束而消失  |
|  初始化值不同  |              有默认的初始化值              | 没有默认的初始化值，必须先定义赋值，才能使用 |



## this和super

| 关键字 |  访问成员变量  | 访问构造方法 |    访问成员方法     |
| :----: | :------------: | :----------: | :-----------------: |
|  this  | this.成员变量  |  this(...)   | this.成员方法(...)  |
| super  | super.成员变量 |  super(...)  | super.成员方法(...) |

​     

## 继承中构造方法的访问特点

子类中所有的构造方法被执行时都会默认访问父类的无参构造方法

1. 因为子类会继承父类中的数据，可能还会使用父类的数据。所以初始化之前，先完成父类数据的初始化。     

2. 每一个子类构造方法的第一条语句默认都是super( );

如果父类中没有无参构造方法，只有带参构造方法，则

1. 可以通过使用super关键字显式调用父类的某一个带参构造方法

2. 当单独定义了带参构造方法时，编译器不再自动定义无参构造方法，可以在父类中自己提供一个无参构造方法              

​      

## 多态

####    **1.多态的形式**

​    具体类多态；抽象类多态；接口类多态

####    **2.实现多态的前提**

1. 有继承/实现的关系

2. 有方法重写

3. 有父类/接口类引用指向子类/实现类对象   

  &ensp;&ensp;&ensp;例：Animal  A=new Cat( );    &ensp;&ensp;//Cat类是Animal类的子类

####    **3.多态中成员访问特点**

1. 成员变量

   编译看左边，执行看左边 (即，如果Animal类中有该变量，则编译成功，且执行时也是用的Animal中该变量的值)

2. 成员方法

   编译看左边，执行看右边 (即，如果Animal类中有该方法，则编译成功；但执行时是看Cat类中该方法的具体实现；

   如果Cat类中没有该方法，则执行父类中的方法)    

   例：

```java
public class Animal{     //定义一个动物类
                       
  public int age=10;
                        
  public void eat(){
                                   
    System.out.println("动物吃东西");                        
  }
}                

//定义一个Cat类继承Animal类,且重写了eat方法
public class Cat extends Animal{    
                               
  public int age=20;
                                
  public int weight=30;
                                                    
  @Override                                 
  public void eat(){
                                          
    System.out.println("猫吃鱼");
  }
                                                                
  public void playGame(){
                                          
    System.out.println("猫捉迷藏");  
  }
}                   
  
Animal a=new Cat();           //父类引用指向子类对象    
  
System.out.println(a.age);    //输出结果为10   
                    
System.out.println(a.weight); //报错  Animal类中没有weight变量
                    
a.eat();        //输出:猫吃鱼
                   
a.playGame();  //报错，不能执行一个子类中独有而父类中没有的方法 
```

####      **4.多态中的转型**

多态的好处：提高了程序的扩展性，定义方法时，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作。

多态的弊端：**实例化的对象不能使用子类的特有功能，而多态的转型可以解决这个问题**。

1. 向上转型

   从子到父，父类引用指向子类对象

   例：Animal a=new Cat();  &ensp;&ensp;//此时，a可以调用父类中的所有成员(有权限的前提下)，但不能调用Cat类中的特有成员

2. 向下转型

   从父到子，父类引用转为子类对象

   例：Cat c=(Cat)a;    &ensp;&ensp;//将a强制转为Cat类，且堆中不会创建新的对象



## 抽象类

​    **一个没有方法体的方法应该定义为抽象方法，如果类中有抽象方法，则该类必须定义为抽象类。**

1. 抽象类中可以只有非抽象方法，如果有抽象方法，一定要定义为抽象类。

2. 抽象类不能直接实例化，但可以参照多态的方式，通过父类引用指向子类对象的方式实现实例化。

3. 抽象类的子类必须重写父类中的所有抽象方法，除非子类也是个抽象类。

 抽象类的成员特点：

1. 成员变量可以是变量，也可以是常量

2. 可以有无参和带参构造方法

3. 有抽象方法，限定子类必须完成某些动作



## 接口类

1. 子类继承接口类时使用implements关键字

   public class 类名 implements 接口名{ }

2. 接口类也需要通过多态的方式进行实例化

   例：Animal a=new Cat( );    &ensp;&ensp;//Animal是接口类，Cat类继承Animal类

3. 接口的实现类

   要么重写接口中的所有抽象方法，要么本身是抽象类。**接口中的所有方法默认被abstract修饰。**

4. 接口类中的成员变量

   1.**成员变量只能是常量，默认被public static final 修饰， 可以通过接口名直接访问。**

   2.接口类没有构造方法，如果有子类继承接口类，则该子类的super()方法调用的是Object类的构造方法。

   3.接口类的成员方法只能是抽象方法，默认被public abstract 修饰，且变量和方法不能用private和protected修饰。

5. 类和接口的关系

   1.类和类的关系

   &ensp;&ensp;继承关系，只能单继承，但是可以多层继承

   2.类和接口的关系

   &ensp;&ensp;实现关系；可以单实现，也可以多实现；还可以在继承一个类的同时实现多个接口

   &ensp;&ensp;例：public class InterImpl implements Inter1,Inter2,Inter3{ }

   3.接口和接口的关系 

   &ensp;&ensp;继承关系，可以单继承，也可以多继承

   &ensp;&ensp;例：public interface Inter3 extends Inter1,Inter2 { }

6. 接口中的默认方法(Java8新增)

   1.定义格式

   &ensp;&ensp;`public default 返回值类型 方法名称(参数列表) {  }` 

   &ensp;&ensp;例：public default void show() { 可以定义具体的实现 }       &ensp;&ensp;//**public关键字可以省略**

   2.特点

   &ensp;&ensp;1.**默认方法不是抽象方法，所以不强制重写，但也可以被子类继承、重写，重写时去掉default关键字**

   &ensp;&ensp;2.如果有个类继承了多个接口，且这些接口中有重名的默认方法，则该类必须重写该方法。可以有重名的抽象方法。

7. 接口中的静态方法

   1.定义格式

   &ensp;&ensp;public static 返回值类型 方法名 (参数列表) {  }

   &ensp;&ensp;例：public static void show() { 具体实现  }         

   2.特点

   &ensp;&ensp;1.**静态方法只能通过接口名调用，不能通过实现类或对象名调用。**

   &ensp;&ensp;2.public可以省略，但static不能省略。   

   &ensp;&ensp;3.因为静态方法只能通过接口名调用，所以**即使类继承了多个接口，这些接口中也可以有重名的静态方法。**

8. 私有方法

   当两个默认方法或者静态方法中包含一段相同的代码时，就可以将这段代码封装成一个共性的方法，

   而这个方法是不需要让别人使用的，因此用私有隐藏起来，所以Java9引入了私有方法.  

   1.定义格式

   ```java
   private 返回值类型 方法名 (参数列表) {  }
   
     例，private void show( ) {  }
   
   private static 返回值类型 方法名(参数列表) {  }
   
     例，private static void method( ) {  }
   ```

   2.特点

   **默认方法可以调用静态的私有方法和非静态的私有方法。**

   **静态方法只能调用静态的私有方法。**  

### 对比

1. 接口中的方法默认是抽象方法，但也可以定义默认方法和静态方法。

2. 接口中的默认方法可以由接口的实现类直接调用，静态方法可以通过接口名直接调用。

3. 抽象类中也可以定义默认方法和静态方法。

4. 抽象类中的静态方法可以被继承类直接调用，默认方法只能通过实例化对象进行调用。

## 内部类

 在一个类中再定义一个类

```java
 public class Outer{
         
     public class Inner{
          
     }
      
 }  
```

1. 内部类可以访问外部类的成员，包括私有的

2. 外部类要访问内部类成员，必须创建对象

 成员内部类

&ensp;&ensp;**在类中定义一个类，可以看做外部类的成员**

&ensp;&ensp;创建对象：外部类名.内部类名 对象名=外部类对象.内部类对象

&ensp;&ensp;&ensp;&ensp;例：Outer.Inner a=new Outer().new Inner()      &ensp;&ensp;//前提是Inner的权限是public   不常使用

&ensp;&ensp;&ensp;&ensp;**一般是在外部类的成员方法中直接创建内部类的对象，然后调用内部类的方法。**

局部内部类

&ensp;&ensp;**在外部类的方法中再定义一个类**，外界无法直接使用，需要在方法内部创建对象并使用

 &ensp;&ensp;该类可以直接访问外部类的成员，也可以访问方法内的局部成员变量。

​    























